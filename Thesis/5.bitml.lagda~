%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Formal Model II: BitML Calculus}
\label{sec:bitml}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Now let us shift our focus to our second subject of study, the BitML calculus for modelling smart contracts.
In this subsection we sketch the formalized part of BitML we have covered so far, namely the syntax and small-step
semantics of BitML contracts, as well as an example execution of a contract under these semantics.
All code is publicly available on Github\site{https://github.com/omelkonian/formal-bitml}.

First, we begin with some basic definitions that will be used throughout this section:
\begin{agda}\begin{code}
module Types (Participant : Set) (Honest : List SUPPLUS Participant) where
##
Time : Set
Time = â„•
##
Value : Set
Value = â„•
##
record Deposit : Set where
  constructor UL has UR
  field  participant : Participant
         value       : Value
##
Secret : Set
Secret = String
##
data Arith : List Secret â†’ Set where DOTS
â„•âŸ¦ U âŸ§ : âˆ€ {s} â†’ Arith s â†’ â„•
â„•âŸ¦ U âŸ§ = DOTS
##
data Predicate : List Secret â†’ Set where DOTS
ğ”¹âŸ¦ U âŸ§ : âˆ€ {s} â†’ Predicate s â†’ Bool
ğ”¹âŸ¦ U âŸ§ = DOTS
\end{code}\end{agda}
Instead of giving a fixed datatype of participants, we parametrise our module with a given \textit{universe} of participants
and a non-empty list of honest participants.
Representation of time and monetary values is again done using natural numbers,
while we model participant secrets as simple strings\footnote{
Of course, one could provide more realistic types (e.g. words of specific length)
to be closer to the implementation, as shown for the UTxO model in Section~\ref{subsec:eutxo}.
}.
A deposits consists of the participant that owns it and the number of bitcoins it carries.
We, furthermore, introduce a simplistic language of logical predicates and arithmetic expressions with the usual constructs (e.g. numerical addition, logical conjunction) and give the usual semantics (predicates on booleans and arithmetic on naturals).
A more unusual feature of these expressions is the ability to calculate length of secrets (within arithmetic expressions)
and, in order to ensure more type safety later on, all expressions are indexed by the secrets they internally use.

\subsection{Contracts in BitML}
A \textit{contract advertisement} consists of a set of \textit{preconditions},
which require some resources from the involved participants prior to the contract's execution,
and a \textit{contract}, which specifies the rules according to which bitcoins are transferred between participants.

Preconditions either require participants to have a deposit of a certain value on their name (volatile or not) or
commit to a certain secret. Notice the index of the datatype below, which captures the values of all required deposits:
\begin{agda}\begin{code}
data Precondition : List Value â†’ Set where
  -- volatile deposit
  U ? U : Participant â†’ (v : Value) â†’ Precondition [ v ]
  -- persistent deposit
  U ! U : Participant â†’ (v : Value) â†’ Precondition [ v ]
  -- committed secret
  UL â™¯ UR : Participant â†’ Secret â†’ Precondition []
  -- conjunction
  U âˆ§ U : Precondition vs SUBL â†’ Precondition vs SUBR â†’ Precondition (vs SUBL ++ vs SUBR)
\end{code}\end{agda}

Moving on to actual contracts, we define them by means of a collection of five types of commands;
|put| injects participant deposits and revealed secrets in the remaining contract,
|withdraw| transfers the current funds to a participant,
|split| distributes the current funds across different individual contracts,
|U : U| requires the authorization from a participant to proceed
and |after U : U| allows further execution of the contract only after some time has passed.
\begin{agda}\begin{code}
data Contract  :  Value   -- the monetary value it carries
               â†’  Values  -- the deposits it presumes
               â†’  Set where
  -- collect deposits and secrets
  put U reveal U if U â‡’ U âˆ¶- U :
    (vs : List Value) â†’ (s : Secrets) â†’ Predicate sâ€²  â†’ Contract (v + sum vs) vsâ€² â†’  sâ€² âŠ† s
    â†’ Contract v (vsâ€² ++ vs)
  -- transfer the remaining balance to a participant
  withdraw : âˆ€ {v} â†’ Participant â†’ Contract v []
  -- split the balance across different branches
  split :  (cs : List (âˆƒ[ v ] ^^ âˆƒ[ vs ] ^^ Contract v vs))
        â†’  Contract (sum (projâ‚ <$$> cs)) (concat (projâ‚‚ <$$> cs))
  -- wait for participant's authorization
  U : U : Participant â†’ Contract v vs â†’ Contract v vs
  -- wait until some time passes
  after U : U : Time â†’ Contract v vs â†’ Contract v vs
\end{code}\end{agda}
There is a lot of type-level manipulation across all constructors, since we need to make sure that indices are
calculated properly. For instance, the total value in a contract constructed by the |split| command is the
sum of the values carried by each branch.
The |put| command\footnote{
|put| comprises of several components and we will omit those that do not contain any helpful information,
e.g. write |put U â‡’ U| when there are no revealed secrets and the predicate trivially holds.
} additionally requires an explicit proof that the predicate
of the |if| part only uses secrets revealed by the same command.

We also introduce an intuitive syntax for declaring the different branches of a |split| command, emphasizing the
\textit{linear} nature of the contract's total monetary value:
\begin{agda}\begin{code}
UL âŠ¸ UR : âˆ€ {vs : Values} â†’ (v : Value) â†’ Contract v vs â†’ âˆƒ[ v ] ^^ âˆƒ[ vs ] ^^ Contract v vs
UL âŠ¸ UR {vs} v c = v , vs , c
\end{code}\end{agda}

Having defined both preconditions and contracts, we arrive at the definition of a contract advertisement:
\begin{agda}\begin{code}
record Advertisement (v : Value) (vs SUPC vs SUPG : List Value) : Set where
  constructor U âŸ¨ U âŸ©âˆ¶- U
  field  G      :  Precondition vs
         C      :  Contracts v vs
         valid  :  length vs SUPC â‰¤ length vs SUPG
                Ã—  participants SUPG G ++ participants SUPC C âŠ† (participant <$$> persistentDeposits SUPP G)
\end{code}\end{agda}
Notice that in order to construct an advertisement, one has to also provide proof of the contract's validity with respect to
the given preconditions, namely that all deposit references in the contract are declared in the precondition
and each involved participant is required to have a persistent deposit.

To clarify things so far, let us see a simple example of a contract advertisement:
\begin{agda}\begin{code}
open BitML (A | B) [ A ] SUPPLUS

ex-ad : Advertisement 5 [ 200 ] (200 âˆ· 100 âˆ· [])
ex-ad =  âŸ¨  B ! 200 âˆ§ A ! 100 ^^ âŸ©
          split  (  2 âŠ¸ withdraw B
                 âŠ•  2 âŠ¸ after 100 âˆ¶ withdraw A
                 âŠ•  1 âŠ¸ put [ 200 ] â‡’ B âˆ¶ withdraw {201} A âˆ¶- DOTS
                 )
          âˆ¶- DOTS
\end{code}\end{agda}
We first need to open our module with a fixed set of participants (in this case |A| and |B|).
We then define an advertisement, whose type already says a lot about what is going on;
it carries \bitcoin ~5, presumes the existence of at least one deposit of \bitcoin ~200, and requires two deposits
of \bitcoin ~200 and \bitcoin ~100.

Looking at the precondition itself, we see that the required deposits will be provided by |B| and |A|, respectively.
The contract first splits the bitcoins across three branches:
the first one gives \bitcoin ~2 to |B|, the second one gives \bitcoin ~2 to |A| after some time period,
while the third one retrieves |B|'s deposit of \bitcoin ~200 and allows |B| to authorise the
withdrawal of the remaining funds (currently \bitcoin ~201) from |A|.

We have omitted the proofs that ascertain the well-formedness of the |put| command and the advertisement, as
they are straightforward and do not provide any more intuition\footnote{
In fact, we have defined decidable procedures for all such proofs using the
\textit{proof-by-reflection} pattern~\cite{proofbyreflection}.
These automatically discharge all proof obligations, when there are no variables involved.}.

\subsection{Small-step Semantics}
BitML is a \textit{process calculus}, which is geared specifically towards smart contracts.
Contrary to most process calculi that provide primitive operators for inter-process communication via
message-passing~\cite{csp}, the BitML calculus does not provide such built-in features.

It, instead, provides domain-specific synchronization mechanisms through its \textit{small-step} reduction semantics.
These essentially define a \textit{labelled transition system} between \textit{configurations}, where
\textit{action} labels are emitted on every transition and represent the required actions of the participants.
This symbolic model consists of two layers; the bottom one transitioning between \textit{untimed} configurations and the top one
that works on \textit{timed} configurations.

We start with the datatype of actions, which showcases the principal actions required to satisfy an advertisement's preconditions
and an action to pick one branch of a collection of contracts (introduced by the choice operator |âŠ•|).
We have omitted uninteresting actions concerning the manipulation of deposits, such as dividing, joining, donating and destroying them.
Since we will often need versions of the types of advertisements/contracts with their
indices existentially quantified, we first provide aliases for them.
\begin{agda}\begin{code}
AdvertisedContracts : Set
AdvertisedContracts = List (âˆƒ[ v ] ^^ âˆƒ[ vs SUPC ] ^^ âˆƒ[ vs SUPG ] ^^ Advertisement v vs SUPC vs SUPG)
##
ActiveContracts : Set
ActiveContracts = List (âˆƒ[ v ] ^^ âˆƒ[ vs ] ^^ List (Contract v vs))
##
data Action (p : Participant)  -- the participant that authorises this action
  :  AdvertisedContracts       -- the contract advertisments it requires
  â†’  ActiveContracts           -- the active contracts it requires
  â†’  Values                    -- the deposits it requires from this participant
  â†’  List Deposit              -- the deposits it produces
  â†’  Set where
##
  -- commit secrets to stipulate an advertisement
  HTRI UR  :  (ad : Advertisement v vs SUPC vs SUPG)
               â†’  Action p [ v , vs SUPC , vs SUPG , ad ] [] [] []

  -- spend x to stipulate an advertisement
  U STRI UR  :  (ad : Advertisement v vs SUPC vs SUPG)
                     â†’  (i : Index vs SUPG)
                     â†’  Action p [ v , vs SUPC , vs SUPG , ad ] [] [ vs SUPG â€¼ i ] []

  -- pick a branch
  U BTRI UR  :  (c : List (Contract v vs))
                     â†’  (i : Index c)
                     â†’  Action p [] [ v , vs , c ] [] []

  VDOTS
\end{code}\end{agda}
The action datatype is parametrised\footnote{
In Agda, datatype parameters are similar to indices, but are not allowed to vary across constructors.
}
over the participant who performs it
and includes several indices representing the prerequisites the current configuration has to satisfy, in order for
the action to be considered valid (e.g. one cannot spend a deposit to stipulate an advertisement that does not exist).

The first index refers to advertisements that appear in the current configuration, the second to contracts that have
already been stipulated, the third to deposits owned by the participant currently performing the action and the fourth
declares new deposits that will be created by the action
(e.g. dividing a deposit would require a single deposit as the third index and produce two other deposits in its fourth index).

Although our indexing scheme might seem a bit heavyweight now, it makes many little details and assumptions explicit,
which would bite us later on when we will need to reason about them.

Continuing from our previous example advertisement, let's see an example action where |A| spends the required \bitcoin ~100
to stipulate the example contract\footnote{
Notice that we have to make all indices of the advertisement explicit in the second index in the action's type signature.
}:
\begin{agda}\begin{code}
ex-spend : Action A [ 5 , [ 200 ] , 200 âˆ· 100 âˆ· [] , ex-ad ] [] [ 100 ] []
ex-spend = ex-ad STRI 1
\end{code}\end{agda}

Configurations are now built from advertisements, active contracts, deposits, action authorizations and committed/revealed secrets:
\begin{agda}\begin{code}
data Configurationâ€²  :  -- $\hspace{22pt}$ current $\hspace{20pt}$ $\times$ $\hspace{15pt}$ required
                        AdvertisedContracts  Ã— AdvertisedContracts
                     â†’  ActiveContracts      Ã— ActiveContracts
                     â†’  List Deposit         Ã— List Deposit
                     â†’  Set where

  -- empty
  âˆ… : Configurationâ€² ([] , []) ([] , []) ([] , [])

  -- contract advertisement
  ` U  :  (ad : Advertisement v vs SUPC vs SUPG)
           â†’  Configurationâ€² ([ v , vs SUPC , vs SUPG , ad ] , []) ([] , []) ([] , [])

  -- active contract
  âŸ¨ U , U âŸ© SUPCC  :  (c : List (Contract v vs)) â†’ Value
                           â†’  Configurationâ€² ([] , []) ([ v , vs , c ] , []) ([] , [])

  -- deposit redeemable by a participant
  âŸ¨ UR , U âŸ© SUPD  :  (p : Participant) â†’ (v : Value)
                           â†’  Configurationâ€² ([] , []) ([] , []) ([ p has v ] , [])

  -- authorization to perform an action
  UL [ U ]  : (p : Participant) â†’ Action p ads cs vs ds
                    â†’ Configurationâ€² ([] , ads) ([] , cs) (ds , ((p has U) <$$> vs))

  -- committed secret
  âŸ¨ U âˆ¶ U â™¯ U âŸ©  :  Participant â†’  Secret â†’  â„• âŠ âŠ¥
                             â†’  Configurationâ€² ([] , []) ([] , []) ([] , [])
  -- revealed secret
  U âˆ¶ U â™¯ U  :  Participant â†’  Secret â†’ â„•
                         â†’  Configurationâ€² ([] , []) ([] , []) ([] , [])

  -- parallel composition
  U | U  :  Configurationâ€² (ads SUPL , rads SUPL) (cs SUPL , rcs SUPL) (ds SUPL , rds SUPL)
                 â†’  Configurationâ€² (ads SUPR , rads SUPR) (cs SUPR , rcs SUPR) (ds SUPR , rds SUPR)
                 â†’  Configurationâ€²  (ads SUPL                    ++ ads SUPR  , rads SUPL  ++ (rads SUPR  âˆ– ads SUPL))
                                    (cs SUPL                     ++ cs SUPR   , rcs SUPL   ++ (rcs SUPR   âˆ– cs SUPL))
                                    ((ds SUPL âˆ– rds SUPR)        ++ ds SUPR   , rds SUPL   ++ (rds SUPR   âˆ– ds SUPL))
\end{code}\end{agda}
The indices are quite involved, since we need to record both the current advertisements, stipulated contracts and deposits
and the required ones for the configuration to become valid. The most interesting case is the parallel composition
operator, where the resources provided by the left operand might satisfy some requirements of the right operand. Moreover,
consumed deposits have to be eliminated as there can be no double spending, while the number of advertisements and contracts
always grows.

By composing configurations together, we will eventually end up in a \textit{closed} configuration, where
all required indices are empty (i.e. the configuration is self-contained):
\begin{agda}\begin{code}
Configuration : AdvertisedContracts â†’ ActiveContracts â†’ List Deposit â†’ Set
Configuration ads cs ds = Configurationâ€² (ads , []) (cs , []) (ds , [])
\end{code}\end{agda}

We are now ready to declare the inference rules of the bottom layer of our small-step semantics,
by defining an inductive datatype modelling the binary step relation between untimed configurations:
\begin{agda}\begin{code}
data U â€”â†’ U : Configuration ads cs ds â†’ Configuration adsâ€² csâ€² dsâ€² â†’ Set where
  DEP-AuthJoin :
    âŸ¨ A , v âŸ© SUPD | âŸ¨ A , vâ€² âŸ© SUPD | Î“ â€”â†’ âŸ¨ A , v âŸ© SUPD | âŸ¨ A , vâ€² âŸ© SUPD | A [ 0 â†” 1 ] | Î“
##
  DEP-Join :
    âŸ¨ A , v âŸ© SUPD | âŸ¨ A , vâ€² âŸ© SUPD | A [ 0 â†” 1 ] | Î“ â€”â†’ âŸ¨ A , v + vâ€² âŸ© SUPD | Î“
##
  C-Advertise : âˆ€ {Î“ ad}
    â†’  âˆƒ[ p âˆˆ participants SUPG (G ad) ] p âˆˆ Hon
       {- $\inferLarge$ -}
    â†’  Î“ â€”â†’ ` ad | Î“
##
  C-AuthCommit : âˆ€ {A ad Î“}
    â†’  secrets (G ad) â‰¡ aâ‚€ DOTS aâ‚™
    â†’  (A âˆˆ Hon â†’ âˆ€[ i âˆˆ 0 DOTS n ] a SUBI â‰¢ âŠ¥)
       {- $\inferLarge$ -}
    â†’  ` ad | Î“ â€”â†’ ` ad | Î“ | DOTS âŸ¨ A : a SUBI â™¯ N SUBI âŸ© DOTS ^^ BAR ^^ A [ â™¯â–· ^^ ad ]
##
  C-Control : âˆ€ {Î“ C i D}
    â†’  C â€¼ i â‰¡ Aâ‚ : Aâ‚‚ : DOTS : Aâ‚™ : D
       {- $\inferLarge$ -}
    â†’  âŸ¨ C , v âŸ© SUPCC | DOTS A SUBI [ C BTRI i ] DOTS | Î“ â€”â†’ âŸ¨ D , v âŸ© SUPCC | Î“
  VDOTS
\end{code}\end{agda}
There is a total of 18 rules we need to define, but we choose to depict only a representative subset of them.
The first pair of rules initially appends the authorisation to merge
two deposits to the current configuration (rule |DEP-AuthJoin|) and then performs the actual join (rule |[DEP-Join]|).
This is a common pattern across all rules, where we first collect authorisations for an action by all involved participants,
and then we fire a subsequent rule to perform this action.
|[C-Advertise]| advertises a new contract, mandating that at least one of the participants involved in the pre-condition
is honest and requiring that all deposits needed for stipulation are available in the surrounding context.
|[C-AuthCommit]| allows participants to commit to the secrets required by the contract's pre-condition, but only dishonest
ones can commit to the invalid length $\bot$.
Lastly, |[C-Control]| allows participants to give their authorization required by a particular branch out of the current
choices present in the contract, discarding any time constraints along the way.

It is noteworthy to mention that during the transcriptions of the complete set of rules from the paper~\cite{bitml}
to our dependently-typed setting,
we discovered a discrepancy in the |[C-AuthRev]| rule, namely that there was no context $\Gamma$.
Moreover, in order to later facilitate equational reasoning, we re-factored the |[C-Control]|
to not contain the inner step as a hypothesis, but instead immediately inject it in the result operand of the step relation.

The inference rules above have elided any treatment of timely constraints;
this is handled by the top layer, whose states are now timed configurations.
The only interesting inference rule is the one that handles time decorations of the form |after U : U|,
since all other cases are dispatched to the bottom layer (which just ignores timely aspects).
\begin{agda}\begin{code}
record Configuration SUPT (ads : AdvertisedContracts) (cs  : ActiveContracts) (ds  : Deposits) : Set where
  constructor U at U
  field  cfg   : Configuration ads cs ds
         time  : Time
##
data U â€”â†’ SUBT U : Configuration SUPT ads cs ds â†’ Configuration SUPT adsâ€² csâ€² dsâ€² â†’ Set where

  Action : âˆ€ {Î“ Î“â€² t}
    â†’  Î“ â€”â†’ Î“â€²
       {- $\inferSmall$ -}
    â†’  Î“ at t â€”â†’ SUBT Î“â€² at t

  Delay : âˆ€ {Î“ t Î´}
       {- $\inferMedium$ -}
    â†’  Î“ at t â€”â†’ SUBT Î“ at (t + Î´)

  Timeout : âˆ€ {Î“ Î“â€² t i contract}
    â†’  All (U â‰¤ t) (timeDecorations (contract â€¼ i))  -- all time constraints are satisfied
    â†’  âŸ¨ [ contract â€¼ i ] , v âŸ© SUPCC | Î“ â€”â†’ Î“â€²          -- resulting state if we pick this branch
       {- $\inferMedium$ -}
    â†’  (âŸ¨ contract , v âŸ© SUPCC | Î“) at t â€”â†’ SUBT Î“â€² at t
\end{code}\end{agda}

Having defined the step relation in this way allows for equational reasoning, a powerful tool for
writing complex proofs:
\begin{agda}\begin{code}
data U â€”â†  U : Configuration ads cs ds â†’ Configuration adsâ€² csâ€² dsâ€² â†’ Set where

  U âˆ : (M : Configuration ads cs ds) â†’ M â€”â†  M

  U â€”â†’ âŸ¨ U âŸ© U : âˆ€ {M  N} (L : Configuration ads cs ds)
    â†’  L â€”â†’ M â†’ M â€”â†  N
       {- $\inferMedium$ -}
    â†’  L â€”â†  N

begin U : âˆ€ {M N} â†’ M â€”â†  N â†’ M â€”â†  N
\end{code}\end{agda}

\subsection{Example}
We are finally ready to see a more intuitive example of the \textit{timed-commitment protocol}, where a participant
commits to revealing a valid secret $a$ (e.g. "qwerty") to another participant,
but loses her deposit of \bitcoin ~1 if she does not meet a certain deadline $t$:
\begin{agda}\begin{code}
tc : Advertisement 1 [] (1 âˆ· 0 âˆ· [])
tc =  âŸ¨ A ! 1 âˆ§ A â™¯ a âˆ§ B ! 0 âŸ© ^^ reveal [ a ] â‡’ withdraw A âˆ¶- DOTS ^^ âŠ• ^^ after t âˆ¶ withdraw B
\end{code}\end{agda}

Below is one possible reduction in the bottom layer of our small-step semantics, demonstrating the case where
the participant actually meets the deadline:
\begin{agda}\begin{code}
tc-semantics : âŸ¨ A , 1 âŸ© SUPD â€”â†  âŸ¨ A , 1 âŸ© SUPD | A âˆ¶ a â™¯ 6
tc-semantics =
  begin
    âŸ¨ A , 1 âŸ© SUPD
  â€”â†’âŸ¨ C-Advertise âŸ©
    ` tc | âŸ¨ A , 1 âŸ© SUPD
  â€”â†’âŸ¨ C-AuthCommit âŸ©
    ` tc | âŸ¨ A , 1 âŸ© SUPD | âŸ¨A âˆ¶ a â™¯ 6âŸ© | A [ HTRI tc ]
  â€”â†’âŸ¨ C-AuthInit âŸ©
    ` tc | âŸ¨ A , 1 âŸ© SUPD | âŸ¨A âˆ¶ a â™¯ 6âŸ© | A [ HTRI tc ] | A [ tc STRI 0 ]
  â€”â†’âŸ¨ C-Init âŸ©
    âŸ¨ tc , 1 âŸ© SUPCC | âŸ¨ A âˆ¶ a â™¯ injâ‚ 6 âŸ©
  â€”â†’âŸ¨ C-AuthRev âŸ©
    âŸ¨ tc , 1 âŸ© SUPCC | A âˆ¶ a â™¯ 6
  â€”â†’âŸ¨ C-Control âŸ©
    âŸ¨ [ reveal [ a ] â‡’ withdraw A âˆ¶- DOTS ] , 1 âŸ© SUPCC | A âˆ¶ a â™¯ 6
  â€”â†’âŸ¨ C-PutRev âŸ©
    âŸ¨ [ withdraw A ] , 1 âŸ© SUPCC | A âˆ¶ a â™¯ 6
  â€”â†’âŸ¨ C-Withdraw âŸ©
    âŸ¨ A , 1 âŸ© SUPD | A âˆ¶ a â™¯ 6
  âˆ
\end{code}\end{agda}
At first, |A| holds a deposit of \bitcoin ~1, as required by the contract's precondition.
Then, the contract is advertised and the participants slowly provide the corresponding prerequisites
(i.e. |A| commits to a secret via |C-AuthCommit| and spends the required deposit via |C-AuthInit|,
while |B| does not do anything).
After all pre-conditions have been satisfied, the contract is stipulated (rule |C-Init|) and the secret is successfully
revealed (rule |C-AuthRev|).
Finally, the first branch is picked (rule |C-Control|) and |A| retrieves her deposit back
(rules |C-PutRev| and |C-Withdraw|).

\subsection{Reasoning Modulo Permutation}
In the definitions above, we have assumed that |(UL BAR UR , âˆ…)| forms a commutative monoid, which allowed us
to always present the required sub-configuration individually on the far left of a composite configuration.
While such definitions enjoy a striking similarity to the ones appearing in the original paper~\cite{bitml}
(and should always be preferred in an informal textual setting),
this approach does not suffice for a mechanized account of the model.
After all, this explicit treatment of all intuitive assumptions/details is what makes our approach robust and will lead to
a deeper understanding of how these systems behave.
To overcome this intricacy, we introduce an \textit{equivalence relation} on configurations, which holds when
they are just permutations of one another:
\begin{agda}\begin{code}
U â‰ˆ U : Configuration ads cs ds â†’ Configuration ads cs ds â†’ Set
c â‰ˆ câ€² = cfgToList c â†­ cfgToList câ€²
  where
    open import Data.List.Permutation using (U â†­ U)

    cfgToList : Configurationâ€² pâ‚ pâ‚‚ pâ‚ƒ â†’ List (âˆƒ[ pâ‚ ] ^^ âˆƒ[ pâ‚‚ ] ^^ âˆƒ[ pâ‚ƒ ] ^^ Configurationâ€² pâ‚ pâ‚‚ pâ‚ƒ)
    cfgToList  âˆ…                 = []
    cfgToList  (l | r)           = cfgToList l ++ cfgToList r
    cfgToList  {pâ‚} {pâ‚‚} {pâ‚ƒ} c  = [ pâ‚ , pâ‚‚ , pâ‚ƒ , c ]
\end{code}\end{agda}
Given this reordering mechanism, we now need to generalise all our inference rules to implicitly
reorder the current and next configuration of the step relation.
We achieve this by introducing a new variable for each of the operands of the resulting step relations,
replacing the operands with these variables and requiring that they are
re-orderings of the previous configurations, as shown in the following generalisation of the |DEP-AuthJoin| rule\footnote{
In fact, it is not necessary to reorder both ends for the step relation; at least one would be adequate.
}:
\begin{agda}\begin{code}
  DEP-AuthJoin :
       Î“â€² â‰ˆ âŸ¨ A , v âŸ© SUPD | âŸ¨ A , vâ€² âŸ© SUPD | Î“                ^^  âˆˆ Configuration ads cs (A has v âˆ· A has vâ€² âˆ· ds)
    â†’  Î“â€³ â‰ˆ âŸ¨ A , v âŸ© SUPD | âŸ¨ A , vâ€² âŸ© SUPD | A [ 0 â†” 1 ] | Î“  ^^  âˆˆ Configuration ads cs (A has (v + vâ€²) âˆ· ds)
       {- $\inferMedium$ -}
    â†’  Î“â€² â€”â†’ Î“â€³
\end{code}\end{agda}

Unfortunately, we now have more proof obligations of the re-ordering relation lying around, which makes reasoning about
our semantics rather tedious. We are currently investigating different techniques to model such reasoning up to equivalence:
\begin{itemize}
\item \textit{Quotient types}~\cite{quotient} allow equipping a type with an equivalence relation.
If we assume the axiom that two elements of the underlying type are \textit{propositionally} equal when they are equivalent,
we could discharge our current proof burden trivially by reflexivity.
Unfortunately, while one can easily define \textit{setoids} in Agda, there is not enough support from the underlying type system to make reasoning about such an equivalence as easy as with built-in equality.
\item Going a step further into more advanced notions of equality, we arrive at \textit{homotopy type theory}~\cite{homotopy},
which tries to bridge the gap between reasoning about isomorphic objects in informal pen-paper proofs
and the way we achieve this in mechanized formal methods.
Again, realizing practical systems with such an enriched theory is a topic of current research~\cite{cubical} and no mature implementation exists yet, so we cannot integrate it with our current development in any pragmatic way.
\item The crucial problems we have encountered so far are attributed to the non-deterministic nature of BitML, which is actually
inherent in any process calculus. Building upon this idea, we plan to take a step back and investigate different reasoning
techniques for a minimal process calculus. Once we have an approach that is more suitable, we will incorporate it
in our full-blown BitML calculus.
\end{itemize}

\subsection{Symbolic Model}
In order to formalize the BitML's symbolic model, we first notice that a constructed derivation
witnesses one of many possible contract executions.
In other words, derivations of our small-step semantics model \textit{traces} of the contract execution.
Our symbolic model will provide a game-theoretic view over those traces, where each participant has a certain
\textit{strategy} that selects moves depending on the current trace of previous moves.
Moves here should be understood just as emissions of a label, i.e. application of a certain inference rule.

\subsubsection{Labelled Step Relation}
To that end, we associate a label to each inference rule and
extend the original step relation to additionally emit labels,
hence defining a \textit{labelled transition system}.

We first define the set of labels, which basically distinguish which rule was used,
along with all (non-proof) arguments that are required by the rule:
\begin{agda}\begin{code}
data Label : Set where
##
  auth-join[ _ , _ â†” _ ] : Participant â†’  DepositIndex â†’ DepositIndex â†’ Label
  join[ _ â†” _ ] :                         DepositIndex â†’ DepositIndex â†’ Label
##
  auth-divide[ _ , _ â–· _ , _ ] : Participant â†’  DepositIndex â†’ Value â†’ Value â†’ Label
  divide[ _ â–· _ , _ ] :                         DepositIndex â†’ Value â†’ Value â†’ Label
##
  auth-donate[ _ , _ â–· SD _ ] : Participant â†’  DepositIndex â†’ Participant â†’ Label
  donate[ _ â–· SD _ ] :                         DepositIndex â†’ Participant â†’ Label
##
  auth-destroy[ _ , _ ] : Participant â†’ DepositIndex â†’ Label
  destroy[ _ ] :                              DepositIndex â†’ Label
##
  advertise[ _ ] : âˆƒAdvertisement â†’ Label
##
  auth-commit[ _ , _ , _ ] : Participant â†’ âˆƒAdvertisement â†’ List CommittedSecret â†’ Label
  auth-init[ _ , _ , _ ] : Participant â†’ âˆƒAdvertisement â†’ DepositIndex â†’ Label
  init[ _ ] : âˆƒAdvertisement â†’ Label
##
  split : Label
##
  auth-rev[ _ , _ ] : Participant â†’ Secret â†’ Label
  rev[ _ , _ ] : Values â†’ Secrets â†’ Label
##
  withdraw[ _ , _ ] : Participant â†’ Value â†’ Label
##
  auth-control[ _ , _ â–· SB _] : Participant â†’ (c : âˆƒContracts) â†’ Index (projâ‚‚ (projâ‚‚ c)) â†’ Label
  control : Label
##
  delay[ _ ] : Time â†’ Label
\end{code}\end{agda}
Notice how we existentially pack indexed types, so that |Label| remains simply-typed.
This is essential, as it would be tedious to manipulate indices when there is no need for them.
Moreover, some indices are now just |â„•| instead of |Fin|, losing the guarantee to not fall out-of-bounds.

The step relation will now emit the corresponding label for each rule. Below, we give
the updated kind signature and an example for the |DEP-AuthJoin| rule:
\begin{agda}\begin{code}
data _ â€”â†’[ _ ] _  :  Configuration ads cs ds
                  â†’  Label
                  â†’  Configuration adsâ€² csâ€² dsâ€²
                  â†’  Set where
  VDOTS
  DEP-AuthJoin :
    âŸ¨ A , v âŸ© SUPD | âŸ¨ A , vâ€² âŸ© SUPD | Î“
  â€”â†’[ auth-join[ A , 0 â†” 1 ] ]
    âŸ¨ A , v âŸ© SUPD | âŸ¨ A , vâ€² âŸ© SUPD | A [ 0 â†” 1 ] | Î“
  VDOTS
\end{code}\end{agda}

Naturally, the reflexive transitive closure of the augmented step relation will now hold a sequence of labels as well:
\begin{agda}\begin{code}
data _ â€”â† âŸ¦ _ âŸ§ _  :  Configuration ads cs ds
                  â†’  Labels
                  â†’  Configuration adsâ€² csâ€² dsâ€²
                  â†’  Set where
##
  _ âˆâˆ  : (M : Configuration ads cs ds)

       {- \inferLine{3cm} -}
    â†’  M â€”â† âŸ¦ [] âŸ§ M
##
  _ â€”â†’âŸ¨ _ âŸ© _ âŠ¢ _ :  (L : Configuration ads cs ds) {Lâ€² : Configuration ads cs ds}
                     {M Mâ€² : Configuration adsâ€² csâ€² dsâ€²} {N : Configuration adsâ€³ csâ€³ dsâ€³}

    â†’  Lâ€² â€”â†’âŸ¦ a âŸ§ Mâ€²
    â†’  (L â‰ˆ Lâ€²) Ã— (M â‰ˆ Mâ€²)
    â†’  M â€”â† âŸ¦ as âŸ§  N
       {- \inferLine{8cm} -}
    â†’  L â€”â† âŸ¦ a âˆ· as âŸ§ N
##
start_ : {M : Configuration ads cs ds} {N : Configuration adsâ€² csâ€² dsâ€²}

  â†’  M â€”â† âŸ¦ as âŸ§ N
     {- \inferLine{3cm} -}
  â†’  M â€”â† âŸ¦ as âŸ§ N

start Mâ€”â† N = Mâ€”â† N
\end{code}\end{agda}
The timed variants of the step relation follow exactly the same procedure, so we do not repeat the definitions here.

\subsubsection{Traces}
Values of type |_ â€”â† [ _ ] _| model execution traces.
Since the complex type indices of the step-relation datatype is not as useful here,
we define a simpler datatype of execution traces that is a list of labelled transitions
between (existentially-packed) timed configurations:
\begin{agda}\begin{code}
data Trace : Set where
  _ âˆ™ : âˆƒTimedConfiguration â†’ Trace
##
  _ âˆ·âŸ¦ _ âŸ§ _ : âˆƒTimedConfiguration â†’ Label â†’ Trace â†’ Trace
\end{code}\end{agda}

\paragraph{Stripping}
Strategies will make moves based on these traces,
so we need a \textit{stripping} operation that traverses a configuration with its emitted labels
and removes any sensitive information (i.e. committed secrets):
\begin{agda}\begin{code}
stripCfg : Configurationâ€² pâ‚ pâ‚‚ pâ‚ƒ â†’ Configurationâ€² pâ‚ pâ‚‚ pâ‚ƒ
stripCfg âŸ¨ p âˆ¶ a â™¯ _ âŸ©  =  âŸ¨ p âˆ¶ a â™¯ nothing âŸ©
stripCfg (l | r âˆ¶- p)   =  stripCfg l | stripCfg r âˆ¶- p
stripCfg c              =  c

stripLabel : Label â†’ Label
stripLabel auth-commit[ p , ad , _ ] = auth-commit[ p , ad , [] ]
stripLabel a = a

_âˆ— : Trace â†’ Trace
(DOTS , Î“ at t) âˆ—          = (DOTS , stripCfg Î“ at t)
(DOTS , Î“ at t) âˆ·âŸ¦ Î± âŸ§ ts  = (DOTS , stripCfg Î“ at t) âˆ·âŸ¦ stripLabel Î± âŸ§ (ts âˆ—)
\end{code}\end{agda}

\subsubsection{Strategies}
\textit{Participant strategies} are functions which, given the (stripped) trace so far, pick
a set of possible next moves for its participant.
These moves cannot be arbitrary; they have to satisfy several validity conditions which
we require as proof in the datatype definition itself.

Strategies are expected to be PPTIME algorithms, so as to have a certain computational bound
on the processing they can undergo to compute secrets, etc.
Since working on a resource-aware logic would make this much more difficult in search of tooling
and infrastructure, we ignore this requirement and simply model strategies as regular functions.

Before we define the types of strategies, we give a convenient notation to extend a trace
with another (timed) transition:
\begin{agda}\begin{code}
_ â€”â€”â†’[ _ ] _ : Trace â†’ Label â†’ âˆƒTimedConfiguration â†’ Set
R â€”â€”â†’[ Î± ] (_ , _ , _ , tcâ€²)
  = projâ‚‚ (projâ‚‚ (projâ‚‚ (lastCfg R))) â€”â†’[ Î± ] tcâ€²
\end{code}\end{agda}

\paragraph{Honest strategies}
Each honest participant is modelled by a symbolic strategy that outputs a set of possible next
moves with respect to the current trace. These moves have to be \textit{valid}, thus we define
\textit{honest strategies} as a dependent record:
\begin{agda}\begin{code}
record HonestStrategy (A : Participant) : Set where
  field
    strategy  :  Trace â†’ Labels

    valid     :  A âˆˆ Hon                                                                         {- (1) -}
              Ã—  (âˆ€ {R : Trace} {Î± : Label} â†’ Î± âˆˆ strategy (R âˆ—) â†’                               {- (2) -}
                   âˆƒ[ Râ€² ] (R â€”â€”â†’[ Î± ] Râ€²))
              Ã—  (âˆ€ {R : Trace} {Î± : Label} â†’ Î± âˆˆ strategy (R âˆ—) â†’                               {- (3) -}
                   Allâ‚˜ (_â‰¡ A) (authDecoration Î±))
                 -- coherent secret lengths
              Ã—  (âˆ€ {R : Trace} {Î” Î”â€² : List CommittedSecret} {ad : âˆƒAdvertisement} â†’            {- (4) -}
                   auth-commit[ A , ad , Î”  ] âˆˆ strategy (R âˆ—) â†’
                   auth-commit[ A , ad , Î”â€² ] âˆˆ strategy (R âˆ—) â†’
                     Î” â‰¡ Î”â€²)
              Ã—  (âˆ€ {R : Trace} {Tâ€² : âˆƒTimedConfiguration} {Î± : Label} â†’ Î± âˆˆ strategy (R âˆ—) â†’    {- (5) -}
                   âˆƒ[ Î±â€² ] (R â€”â€”â†’[ Î±â€² ] Tâ€²) â†’
                   âˆƒ[ Râ€³ ] (Tâ€² âˆ·âŸ¦ Î± âŸ§ R â€”â€”â†’[ Î± ] Râ€³) â†’
                     Î± âˆˆ strategy ((Tâ€² âˆ·âŸ¦ Î± âŸ§ R) âˆ—))
\end{code}\end{agda}
Condition $(1)$ restricts our participants to the honest subset\footnote{
Recall that |Hon| is non-empty, i.e. there is always at least one honest participant.
} and condition $(2)$ requires that chosen moves are in accordance to the small-step semantics of BitML.
Condition $(3)$ states that one cannot authorize moves for other participants,
condition $(4)$ requires that the lengths of committed secrets are \textit{coherent}
(i.e. no different lengths for the same secrets across moves) and
condition $(5)$ dictates that decisions are \textit{consistent}, so as moves that are not chosen will still be
selected by the strategy in a future run (if they are still valid).

All honest participants should be accompanied by such a strategy,
so we pack all honest strategies in one single datatype:
\begin{agda}\begin{code}
HonestStrategies : Set
HonestStrategies = âˆ€ {A} â†’ A âˆˆ Hon â†’ ParticipantStrategy A
\end{code}\end{agda}

\paragraph{Adversary strategies}
All dishonest participant will be modelled by a single adversary |Adv|, whose strategy now additionally
takes the moves chosen by the honest participants and makes the final decision.

Naturally, the chosen move is subject to certain conditions and is again a dependent record:
\begin{agda}\begin{code}
record AdversarialStrategy (Adv : Participant) : Set where
  field
    strategy  :  Trace â†’ List (Participant Ã— Labels) â†’ Label

    valid     :  Adv âˆ‰ Hon                                                {- (1) -}
              Ã—  (âˆ€ {B ad Î”} â†’ B âˆ‰ Hon â†’ Î± â‰¡ auth-commit[ B , ad , Î” ] â†’  {- (2) -}
                   Î± â‰¡ strategy (R âˆ—) [])
              Ã—  âˆ€ {R : Trace} {moves : List (Participant Ã— Labels)} â†’    {- (3) -}
                  let Î± = strategy (R âˆ—) moves in
                  (  âˆƒ[ A ]
                       (  A âˆˆ Hon
                       Ã—  authDecoration Î± â‰¡ just A
                       Ã—  Î± âˆˆ concatMap projâ‚‚ moves )
                  âŠ  (  authDecoration Î± â‰¡ nothing
                     Ã—  (âˆ€ Î´ â†’ Î± â‰¢ delay[ Î´ ])
                     Ã—  âˆƒ[ Râ€² ] (R â€”â€”â†’[ Î± ] Râ€²) )
                  âŠ  (âˆƒ[ B ]
                        (  (authDecoration Î± â‰¡ just B)
                        Ã—  (B âˆ‰ Hon)
                        Ã—  (âˆ€ s â†’ Î± â‰¢ auth-rev[ B , s ])
                        Ã—  âˆƒ[ Râ€² ] (R â€”â€”â†’[ Î± ] Râ€²) ))
                  âŠ  âˆƒ[ Î´ ]
                       (  (Î± â‰¡ delay[ Î´ ])
                       Ã—  All (Î»{ (_ , Î›) â†’  (Î› â‰¡ []) âŠ  Any (Î»{ delay[ Î´â€² ] â†’ Î´â€² â‰¥ Î´ ; _ â†’ âŠ¥ }) Î›}) moves )
                  âŠ  âˆƒ[ B ] âˆƒ[ s ]
                       (  Î± â‰¡ auth-rev[ B , s ]
                       Ã—  B âˆ‰ Hon
                       Ã—  âŸ¨ B âˆ¶ s â™¯ nothing âŸ© âˆˆ (R âˆ—)
                       Ã—  âˆƒ[ Râˆ—â€² ] âˆƒ[ Î” ] âˆƒ[ ad ]
                            (  Râˆ—â€² âˆˆ prefixTraces (R âˆ—)
                            Ã—  strategy Râˆ—â€² [] â‰¡ auth-commit[ B , ad , Î” ]
                            Ã—  (s , nothing) âˆˆ Î” )))
\end{code}\end{agda}
The first two conditions state that the adversary is not one of the honest participants
and that committing cannot depend on the honest moves, respectively.
The third condition constraints the move that is chosen by the adversary, such that
one of the following conditions hold:
\begin{enumerate}
\item The move was chosen out of the available honest moves.
\item It is not a |delay|, nor does it require any authorization.
\item It is authorized by a dishonest participant, but is not a secret-revealing move.
\item It is a |delay|, but one that does not influence the time constraints of the honest participants.
\item It reveals a secret from a dishonest participant, in which case there is valid commit (i.e. with non-|âŠ¥| length)
somewhere in the previous trace.
\end{enumerate}

\paragraph{Symbolic Conformance}
...

\subsubsection{Meta-theoretical results}
\paragraph{Stripping preserves semantics}
...
\paragraph{Adversial moves are always semantic}
one of the following should hold:
...

\subsection{BitML Paper Fixes}
... formal verification benefits ...

\subsubsection{[DEP-Join]}
\TODO{why symmetric?}

\subsubsection{[C-AuthRev]}
\TODO{missing |DOTS Î“|}

\subsubsection{[C-Control]}
\TODO{Refactor to allow for ``linear'' equational reasoning}

\subsubsection{Adversarial Strategy}
\TODO{No need for Î» = (Aj,j)}

\subsubsection{Stripping premises}
\TODO{Not only AuthRev, but also AuthCommit}
